[[toc]]

= WLib Documentation
:hardbreaks-option:

== 0. Introduction
// About, composition, and abstraction
This document is the official documentation, or developers' manual, for the WLib library. The documentation provides information on identifiers defined by library header and source files, as well as serves to regulate the way the WLib library is implemented. It is divided into chapters for each the library module, the chapters are further divided into sections. **All identifier names in this documentation are mentioned without the prefix.**

// Parity
The information provided by the documentation should be represented by the implementation (declarations and definitions of identifiers) of this library. The implementation may deviate from the information, provided by the documentation, if it achieves some form optimization or additional compatibility with external libraries or compliance with standards; regardless, the documentation should be updated.

// Formatting
- Identifiers are formatted in monospace (`LikeThis`).
- When files or directories are mentioned, they are formatted in monospace, encapsuled within inequality signs (`<file.h>`). If a directory is at the end of the path, a slash is appended (`<dir/>`).

=== Definitions
_Function_, as a WLib identifier, refers to both functions and function-like macros.

_Identifier_ -- an undelimited sequence of bytes that has a declaration in a source or header file.

_Macro_ is the same thing as preprocessor definition.

_Object-like macro_ are macros that replace the name of the identifier with it's definition.

_Function-like macro_ are macros that do the same thing as object-like macro but also replace the name of parameters in the definition with the identifier passed to those parameters.

_Module_ -- a conceptually divided part of the library containing identifiers, usually comprised of a header file with pre-processor, type, enumerator type, enumerated constant, struct definitions and external variable, function declarations. External functions and variables are defined in source files inside folders dedicated for a module. Modules are usually built either into their separate library file or several modules are built into one library file.

_Type_, as a WLib identifier, -- an identifier that is an alias to a type, as a rule, declared through a `typedef` declaration. Usually, types first letter, excluding the identifier prefix, (`Type` or `__Type` or `_wl_Type`).

_Object_, as a WLib identifier, -- any identifier that is or an alias to a declared object. Usually, types start with a lowercase letter (`object`, or ).

Identifier _prefix_ is the prefix that is applied to an identifier. Default prefix is `wl_` (`WL_` for macros). All identifiers are prefixed (auxiliary identifies may not be prefixed), however each identifier also has an alias without the prefix, unless configured otherwise. If there are libraries that a developer uses, which has a identifier with the same name as a WLib's identifiers, developers can configure to undefine unprefixed aliases, and use all WLib identifiers with the prefix.




== 1. System Information `<sys/>`
The System Information Module consists of several headers: `<arch.h>`
=== 1.1. Architectures
=== 1.2. Operating Systems
=== 1.3. Data models
=== 1.4. Compilers
=== 1.5. Language
== 2. C/C++ compatibility
=== 2.1. `enum`
=== 2.2. `extern`
=== 2.3. `inline`
=== 2.4. `restrict`
== 3. Basic types
=== 3.1. Fixed-width numeric types
=== 3.2. C/C++ compatibility types
=== 3.3. Special types
=== 3.4. Type widths
=== 3.5. Type limits
== 4. Character utilities
Below is the table of ASCII character set.

- Characters belonging to the Control Character Set are inside blue cells (x00--x1F and x7F);
- Characters belonging to the Symbol Character Set are inside yellow cells (x20--x2F and x3A--x40 and x5B--x60 and x7B--x7E);
- Characters belonging to the Digit Character Set are inside pink/magenta cells (x30--x39);
- Characters belonging to the Uppercase Character Set are inside red cells (x41--x5A);
- Characters belonging to the Lowercase Character Set are inside green cells (x61--x7A);
- Characters belonging to the Whitespace Character Set are in red color (x09--x0D);
- The Letter Character Set or Alphabetical Set is a combined set of the Uppercase Character Set and the Lowercase Character Set;
- The Alphanumeric Character Set is a combined set of the Letter Character Set and the Digit Character Set;
- The RFC 4648 Base32 Character Set is a set of characters consisting of the entire Uppercase Letter Character Set, digits from `2` to `7` and the padding character `=`;
- The RFC 4648 Base64 Character Set is a set of characters consisting of the entire Uppercase, Lowercase Letters and Decimal Digit Character Sets, plus character `+`, `/` and the padding character `=`;
- The Extended ASCII Character Set is any character beyond the order number 127 (x7F) or ‚ê° character.
- The Binary Digit Character Set is a set of two characters: `0` and `1`
- The Octal Digit Character Set -- eight characters from `0` to `7`
- The Hexadecimal Digit Character Set -- sixteen characters, including the entire Decimal Digit Character Set and uppercase letter from `A` to `F`
- The Triacontabinary Digit Character Set -- thirty-two character, includes the entire Decimal Digit Character Set and uppercase letter from `A` to `V`
- The Hexecontaquaternary Digit Character Set -- sixty-four character, same as RFC 4648 Base64.

[cols="^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^"]
|===
|			| 00								| 01							| 02							| 03			| 04			| 05		| 06		| 07
| 08		| 09								| 0A							| 0B							| 0C			| 0D			| 0E		| 0F		|
| 00		|{set:cellbgcolor:#EEEEFF} &#9216;	| &#9217;						| &#9218;						| &#9219;		| &#9220;		| &#9221;	| &#9222;	| &#9223;
| &#9224;	|[red]#&#9225;#						|[red]#&#9226;#					|[red]#&#9227;#					|[red]#&#9228;#	|[red]#&#9229;#	| &#9230;	| &#9231;	|{set:cellbgcolor:} 0F
| 10		|{set:cellbgcolor:#EEEEFF} &#9223;	| &#9233;						| &#9234;						| &#9235;		| &#9236;		| &#9237;	| &#9238;	| &#9239;	
| &#9240;	| &#9241;							| &#9242;						| &#9243;						| &#9244;		| &#9245;		| &#9246;	| &#9247;	|{set:cellbgcolor:} 1F
| 20		|{set:cellbgcolor:#FFFFEE} &#9251;	| !								| &quot;						| &num;			| $				| %			| &amp;		| &#39;		
| (			| )									| &ast;							| +								| ,				| -				| .			| /			|{set:cellbgcolor:} 2F
| 30		|{set:cellbgcolor:#FFEEFF} 0		| 1								| 2								| 3				| 4				| 5			| 6			| 7
| 8			| 9									|{set:cellbgcolor:#FFFFEE} :	| ;								| &lt;			| =				| &gt;		| ?			|{set:cellbgcolor:} 3F
| 40		|{set:cellbgcolor:#FFFFEE} @		|{set:cellbgcolor:#FFEEEE} A	| B								| C				| D				| E			| F			| G			
| H			| I									| J								| K								| L				| M				| N			| O			|{set:cellbgcolor:} 4F
| 50		|{set:cellbgcolor:#FFEEEE} P		| Q								| R								| S				| T				| U			| V			| W
| X			| Y									| Z								|{set:cellbgcolor:#FFFFEE} &	| \				| ]				| ^			| _			|{set:cellbgcolor:} 5F
| 60		|{set:cellbgcolor:#FFFFEE} &grave;	|{set:cellbgcolor:#EEFFEE} a	| b								| c				| d				| e			| f			| g
| h			| i									| j								| k								| l				| m				| n			| o			|{set:cellbgcolor:} 6F
| 70		|{set:cellbgcolor:#EEFFEE} p		| q								| r								| s				| t				| u			| v			| w
| x			| y									| z								|{set:cellbgcolor:#FFFFEE} {	| &vert;		| }				| ~			| \			|{set:cellbgcolor:} 7F
|			| 70								| 71							| 72							| 73			| 74			| 75		| 76		| 77
| 78		| 79								| 7A							| 7B							| 7C			| 7D			| 7E		| 7F		|
|===

=== 4.1. Control Characters
The numerical value of ASCII Control Characters can be conveniently accessed using next macros.
[%autowidth]
|===
|DEC|BIN    |OCT|HEX|Name
|0  |0000000|000|00 |`NUL`
|1  |0000001|001|01 |`SOH`
|2  |0000010|002|02 |`STX`
|3  |0000011|003|03 |`ETX`
|4  |0000100|004|04 |`EOT`
|5  |0000101|005|05 |`ENQ`
|6  |0000110|006|06 |`ACK`
|7  |0000111|007|07 |`BEL`
|8  |0001000|010|08 |`BS`
|9  |0001001|011|09 |`HT`
|10 |0001010|012|0A |`LF`
|11 |0001011|013|0B |`VT`
|12 |0001100|014|0C |`FF`
|13 |0001101|015|0D |`CR`
|14 |0001110|016|0E |`SO`
|15 |0001111|017|0F |`SI`
|16 |0010000|020|10 |`DLE`
|17 |0010001|021|11 |`DC1`
|18 |0010010|022|12 |`DC2`
|19 |0010011|023|13 |`DC3`
|20 |0010100|024|14 |`DC4`
|21 |0010101|025|15 |`NAK`
|22 |0010110|026|16 |`SYN`
|23 |0010111|027|17 |`ETB`
|24 |0011000|030|18 |`CAN`
|25 |0011001|031|19 |`EM`
|26 |0011010|032|1A |`SUB`
|27 |0011011|033|1B |`ESC`
|28 |0011100|034|1C |`FS`
|29 |0011101|035|1D |`GS`
|30 |0011110|036|1E |`RS`
|31 |0011111|037|1F |`US`
|127|1111111|177|7F |`DEL`
|===
=== 4.2. Character set checking
Character set checking macro functions check if the specified character belongs to the set of character the function is specified to check against.

*Name*: `ci32`, `ci64`, `cib`, `cic`, `cid`, `cih`, `cihq`, `cil`, `cild`, `cill`, `cin`, `cinx`, `cio`, `cip`, `cis`, `citb`, `ciul`, `civ`, `ciw`, `cix`

*Synopsis*
```c
#define ci32(c)	...
#define ci64(c)	...
#define cib(c)	...
#define cic(c)	...
#define cid(c)	...
#define cih(c)	...
#define cihq(c)	...
#define cil(c)	...
#define cild(c)	...
#define cill(c)	...
#define cin(c)	...
#define cinx(c)	...
#define cio(c)	...
#define cip(c)	...
#define cis(c)	...
#define citb(c)	...
#define ciul(c)	...
#define civ(c)	...
#define ciw(c)	...
#define cix(c)	...
```

*Description*

- `ci32` (Character Is Base32) checks for inclusion in RFC 4648 Base32 Character set,
- `ci64` (Character Is Base64) -- RFC 4648 Base64 Character set,
- `cib` (Character Is Binary digit) -- Binary Digit Character set,
- `cic` (Character Is Control) -- Control Character set
- `cid` (Character Is Decimal digit) -- Decimal Digit Character set,
- `cih` (Character Is Hexadecimal digit) -- Hexadecimal Digit Character set,
- `cihq` (Character Is Hexecontaquaternary digit) -- Hexecontaquaternary Digit Character set,
- `cil` (Character Is Letter) -- Alphabetical Character set,
- `cild` (Character Is Letter or Decimal digit) -- Alphanumerical Character set,
- `cill` (Character Is Lowercase Letter) -- Lowercase Letter Character set,
- `cin` (Character Is blaNk) -- Blank Character set,
- `cinx` (Character Is Not eXtended ASCII) -- Base ASCII Character set,
- `cio` (Character Is Octal digit) -- Octal Digit Character set,
- `cip` (Character Is Printable) -- Printable Character set,
- `cis` (Character Is Symbol) -- Symbol Digit Character set,
- `citb` (Character Is Triacontabinary digit) -- Triacontabinary Digit Character set,
- `ciul` (Character Is Uppercase Letter) -- Uppercase Letter Character set,
- `civ` (Character Is Visible) -- Visible Character set,
- `ciw` (Character Is Whitespace) -- Whitespace Digit set,
- `cix` (Character Is eXtended ASCII) -- Extended ASCII Character set.

*Parameters*: `c` -- character to be checked.

*Returns*: _true_ or _false_.


== 5. Array utilities
=== 5.1. Bitwise arithmetic
Array bitwise arithmetic operation functions are macro function that perform the corresponding logic operation bitwise. 

*Name*: `aan`, `aand`, `anand`, `ann`, `ano`, `anor`, `anot`, `anr`, `ant`, `anx`, `anxor`, `aor`, `axor`, `axr`

*Synopsis*
```c
#define aan(r,a,b,size)	_afa((r),(a),(b),AF_AN,(size))
#define aand	aan
#define anand	ann
#define ann(r,a,b,size)	_afa((r),(a),(b),AF_NN,(size))
#define ano(r,a,size)	_afa((r),(a),NULL,AF_NO,(size))
#define anor	anr
#define anot	ant
#define anr(r,a,b,size)	_afa((r),(a),(b),AF_NR,(size))
#define ant(r,a,size)	_afa((r),(a),NULL,AF_NT,(size))
#define anx(r,a,b,size)	_afa((r),(a),(b),AF_NX,(size))
#define anxor	anx
#define aor(r,a,b,size)	_afa((r),(a),NULL,AF_OR,(size))
#define axor	axr
#define axr(r,a,b,size)	_afa((r),(a),NULL,AF_XR,(size))
```

*Description*

[%autowidth]
|===
|`aan`	|**A**rray **AN**D		|performs bitwise AND on two objects pointed by `a` and `b` and the result object is written at `r`
|`aand`	|**A**rray *AND*		|is an alias of `aan`
|`anand`|**A**rray *NAND*		|is an alias of `ann`
|`ann`	|**A**rray **N**A**N**D	|performs bitwise NAND on two objects pointed by `a` and `b` and the result object is written at `r`
|`ano`	|**A**rray No Operation	|does not perform any operation on the object pointed by `a` and copies that object to the location `r`
|`anor`	|**A**rray *NOR*		|is an alias of `anr`
|`anot`	|**A**rray *NOT*		|is an alias of `ant`
|`anr`	|**A**rray **N**O**R**	|performs bitwise NOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`ant`	|**A**rray **N**O**T**	|performs bitwise NOT on the object pointed by `a` and the result object is written at `r`
|`anx`	|**A**rray **NX**OR		|performs bitwise NXOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`anxor`|**A**rray *NXOR*		|is an alias of `anx`
|`aor`	|**A**rray *OR*			|performs bitwise OR on two objects pointed by `a` and `b` and the result object is written at `r`
|`axor`	|**A**rray *XOR*		|is an alias of `axr`
|`axr`	|**A**rray **X**O**R**	|performs bitwise XOR on two objects pointed by `a` and `b` and the result object is written at `r` 
|===

All of these macro functions eventually end up expanding to `afa`, which is actually responsible for performing the respective operations.

*Parameters*

For `ano`, `ant` and `anot`:

- `a` -- pointer to the operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer.

For `aan`, `ann`, `anr`, `anx`, `aor`, `axr` and their aliases:

- `a` -- pointer to the left operand object;
- `b` -- pointer to the right operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer, the algorithm calls for allocated of size bytes for writing the array; the pointer to that newly allocated sequence of bytes will be assigned to `r`

*Returns*: the value of `r` -- the pointer to the result object

*Configurability*

Next configuration flags are applicable for these functions: `WL_CONF_AAN_FUNC`, `WL_CONF_ANN_FUNC`, `WL_CONF_ANO_FUNC`, `WL_CONF_ANR_FUNC`, `WL_CONF_ANT_FUNC`, `WL_CONF_ANX_FUNC`,`WL_CONF_AOR_FUNC`, `WL_CONF_AXR_FUNC`.


=== 5.2. Boolean logic
Array bitwise arithmetic operation functions are macro function that perform the corresponding logical or standard boolean algebraic operation.

[%autowidth]
|===
|`aanl`		|**A**rray **AN**D **L**ogical	|performs bitwise AND on two objects pointed by `a` and `b` and the result object is written at `r`
|`aandl`	|**A**rray *AND* **L**ogical	|is an alias of `aan`
|`anandl`	|**A**rray *NAND* **L**ogical	|is an alias of `ann`
|`annl`		|**A**rray **N**A**N**D **L**ogical	|performs bitwise NAND on two objects pointed by `a` and `b` and the result object is written at `r`
|`anol`		|**A**rray **N**o **O**peration **L**ogical	|does not perform any operation on the object pointed by `a` and copies that object to the location `r`
|`anorl`	|**A**rray *NOR* **L**ogical	|is an alias of `anr`
|`anotl`	|**A**rray *NOT* **L**ogical	|is an alias of `ant`
|`anrl`		|**A**rray **N**O**R** **L**ogical	|performs bitwise NOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`antl`		|**A**rray **N**O**T** **L**ogical	|performs bitwise NOT on the object pointed by `a` and the result object is written at `r`
|`anxl`		|**A**rray **NX**OR **L**ogical	|performs bitwise NXOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`anxorl`	|**A**rray *NXOR* **L**ogical	|is an alias of `anx`
|`aorl`		|**A**rray *OR* **L**ogical	|performs bitwise OR on two objects pointed by `a` and `b` and the result object is written at `r`
|`axorl`	|**A**rray *XOR* **L**ogical	|is an alias of `axr`
|`axrl`		|**A**rray **X**O**R** **L**ogical	|performs bitwise XOR on two objects pointed by `a` and `b` and the result object is written at `r`
|===


=== 5.3. Searching & Replacing
==== 5.3.1. `asb` -- Array Search Byte
`asb` is a data search utility that looks for the first, last occurrence or the total amount of occurrences of specified byte value.

*Synopsis*:
```c
#define asb(a,s,b,flags)	_asb((char*)(a),(s),(b),(flags))
EXTERN Pt _asb(const char* const restrict a, const As s, const char b, const _Asf flags);
```

*Name*: `asb` -- Array Search Byte

*Parameters*

[%autowidth]
|===
|			| `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `size`	| size of the object in bytes
| `char`	| `b`		| byte value to be searched for (needle)
| `_Asf`	| `flag`	| appropriate Search Flags ORed together
|===

`a` should be of any integer or pointer type.

*Returns*: `Pt`.

*Description*

Check for any byte with value `b`.

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

Flags for tweaking the search target:

- If `AS_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of byte `b`.

Flags for tweaking the return value:

- If `AS_FR` or `AS_FIRST` flag is set or implied, only looks looks for the first occurrence;

- if `AS_LS` or `AS_LAST` flag is set, only looks looks for the last occurrence;

- if `AS_CO` or `AS_COUNT` flag is set, the number of occurrence is returned;

- if `AS_OF` or `AS_OFFSET` flag is set, pointer difference between the base of object `a` (i.e. the value passed as a parameter) and the location of the needle byte, if found, otherwise returns `PTX`;

- if `AS_PT` or `AS_POINTER` flag is set or implied, returns the pointer to the needle byte, if found, otherwise returns `PTN` (`NULL`).

Default flags are: `AS_FR` and `AS_PT`.


==== 5.3.2. `asa` -- Array Search Array
`asa` is a data search utility that looks for the first, last occurrence or the total amount of occurrences of specified object in a larger object.

*Synopsis*:
```c
#define asa(a,sa,b,sb,flags)	_asa((char*)(a),(sa),(char*)(b),(sb),(flags))
EXTERN Pt _asa(const char* const restrict a, const As sa, const char* restrict b, const As sb, const _Asf flags);
```

*Name*: `asa` -- Array Search Array.

*Parameters*

[%autowidth]
|===
|			| `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `sa`		| size of the object `a` in bytes
|			| `b`		| pointer to the object to be searched for (needle)
| `As`		| `sb`		| size of the object `b` in bytes
| `_Asf`	| `flag`	| appropriate Search Flags ORed together
|===

`a` and `b` should be of any integer or pointer type.

*Returns*: `Pt`.

*Description*

Checks for an occurrence of object `b` in object `a`.

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

- If `b` is NULL or `sb` is 0, returns immediately as if no occurrences were found, however, with `AS_NEGATIVE` the count of occurrences will be equal to `PTX`, the last occurrence will be the end of object `a` and the first occurrence at its base; also sends WL_ERRNUL.

Flags for tweaking the search target:

- If `AS_AC` or `AS_ANYCHAR` flag is set, instead of looking for the occurrence of object `b`, the algorithm will look for the occurrence of any byte in the object `b`.

- If `AS_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of object `b`. With `AS_AC` or `AS_ANYCHAR` flag, the algorithm will look for the occurrence of any byte values that object `b` is not comprised of.

Flags for tweaking the return value:

- If `AS_FR` or `AS_FIRST` flag is set or implied, only looks looks for the first occurrence;

- if `AS_LS` or `AS_LAST` flag is set, only looks looks for the last occurrence;

- if `AS_CO` or `AS_COUNT` flag is set, the number of occurrence is returned;

- if `AS_OF` or `AS_OFFSET` flag is set, pointer difference between the base of object `a` (i.e. the value passed as a parameter) and the location of the needle object, if found, otherwise returns `PTX`;

- if `AS_PT` or `AS_POINTER` flag is set or implied, returns the pointer to the needle object, if found, otherwise returns `PTN` (`NULL`).

Default flags are: `AS_FR` and `AS_PT`.


==== 5.3.3. `arb` -- Array Replace Byte

`arb` is a data modification utility that replaces the first, the last or all occurrences of byte `b` with byte `c` in object `a`.

*Synopsis*:
```c
#define arb(a,sa,b,c,flag) ((a) = _arb((char*)(a),(sa),(b),(c),(flag)))
EXTERN char* _arb(const char* restrict const a, const As sa, const char b, const char c, const _Asf flag)
```

*Name*: `arb` -- Array Replace Byte.

*Parameters*

[%autowidth]
|===
|           | `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `size`	| size of the object in bytes
| `char`	| `b`		| byte value to be searched for (needle)
| `char`	| `c`		| byte value to replace to (replacement)
| `_Arf`	| `flag`	| appropriate Search or Replace Flags ORed together
|===

`a` should be of any non-constant integer or pointer type and its object should be of non-const type, because it is a subject to modification and reallocation.

*Returns*: `char*` -- pointer to the modified object `a`.

*Description*:

Replaces the first, last or all occurrences of byte `b` with byte `c` in object `a`. 

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

Flags for tweaking the search target:

- If `AR_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of byte `b`, and if found, will replace those byte with `c`.

Flags for tweaking the return value:

- If `AR_FR` or `AR_FIRST` flag is set or implied, only replaces the first occurrence;

- if `AR_LS` or `AR_LAST` flag is set, only replaces the last occurrence;

- If `AR_ALL` flag is set, every occurrence will be replaced.

Default flags are: `AR_ALL`.

==== 5.3.4. `ara` -- Array Replace Array

`ara` is a data modification utility that replaces the first, the last or all occurrences of object `b` with object `c` in object `a`.

*Synopsis*:
```c
#define ara(a,sa,b,sb,c,sc,flag) ((a) = _ara((char*)(a),(sa),(char*)(b),(sb),(char*)(c),(sc),(flag)))
#define rep		ara
#define replace ara
EXTERN char* _ara(
	char*						a,	const As sa, 
	const char* restrict const	b,	const As sb,
	const char* restrict const	c,	const As sc,
	const _Asf					flag
)
```

*Name*: `arb` -- Array Replace Byte.

*Parameters*

[%autowidth]
|===
|           	| `a` 		| pointer to the object which will be searched (haystack)
| `const As`	| `sa`		| size of the object `a` in bytes
|				| `b`		| byte value to be searched for (needle)
| `const As`	| `sb`		| size of the object `b` in bytes
| 				| `c`		| byte value to replace to (replacement)
| `const As`	| `sc`		| size of the object `c` in bytes
| `const _Arf`	| `flag`	| appropriate Search or Replace Flags ORed together
|===

`a` should be of any non-constant integer or pointer type and its object should be of non-const type, because it is a subject to modification and reallocation.
`b` and `c` should be of any integer or pointer type.

*Returns*: `char*` -- pointer to the modified object `a`.

*Description*:

Replaces the first, last or all occurrences of object `b` with object `c` in object `a`. 

If the sizes of the object `b` and the object `c` are different, the resulting size of object `a` is subject to change. If object size of `c` is bigger than of `b` and replacements have been made, the size of object `a` has increased, therefore it is a subject to reallocation, the algorithm will also assign the return value to `a` for you; unless the WL_CONF_CALL_MAL flag is set to 0, in which case the overflowing bytes will be written right outside the bounds of object `a`.

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

Flags for tweaking the search target:

- If `AR_AC` or `AR_ANYCHAR` flag is set, instead of looking for the occurrence of object `b`, the algorithm will look for the occurrence of any byte in the object `b` and replaces it with respective byte from the object `c`. If there is no respective byte in the object `c` due to size of the object `c` being less than of the object `b`, those bytes will cut, replaced with nothing.

- If `AR_NG` or `AR_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of byte `b`, and if found, will replace those byte with `c`. With `AR_AC` or `AR_ANYCHAR` flag, the algorithm will look for the occurrence of any byte values that object `b` is not comprised of and replace it with the entire object `c`.

Flags for tweaking the return value:

- If `AR_FR` or `AR_FIRST` flag is set or implied, only replaces the first occurrence;

- if `AR_LS` or `AR_LAST` flag is set, only replaces the last occurrence;

- If `AR_AL` or `AR_ALL` flag is set, every occurrence will be replaced.

Default flag is `AR_ALL`.


=== 5.4. Other Identifiers
==== 5.4.1. _Af -- Array Function
`_Af` is type and an enumerator type. The type is only used in the declarations of `_afa` and `_afb` as the type of parameter `func`. The enumerator type holds enumerator constants that can be passed in `func`, each representing a boolean function.

*Synopsis*:
```c
typedef char _Af;
typedef enum _Af {
	_AF_NO = 0,
	_AF_AN = 1,
	_AF_OR = 2,
	_AF_XR = 3,
	_AF_NR = 4,
	_AF_NN = 5,
	_AF_NR = 6,
	_AF_NX = 7
};
```

*Name*: `_Af` -- Array Function

*Description*:

The `_Af` type should large enough to hold the range of values of `_Af`'s constants.

`_Af` contains next constants:

- `_AF_NO` performs no operation;

- `_AF_AN` performs AND (conjunction);

- `_AF_OR` performs OR (disjunction);

- `_AF_XR` performs XOR (exclusive disjunction);

- `_AF_NR` performs NOT (inversion) only on `a`, `b` is ignored;

- `_AF_NN` performs NAND (inverted conjunction);

- `_AF_NR` performs NOR (inverted disjunction);

- `_AF_NX` performs NXOR (inverted exclusive disjunction).

 
==== 5.4.2. _Asf -- Array Search Flags
`_Asf` is type and an enumerator type. The type is only used in the declarations of `asb` and `asa` as the type of parameter `flags`. The enumerator type holds enumerator constants that can be passed in `flags`, each signalling the way objects will be search and the return value.

*Synopsis*:
```c
typedef unsigned char _Asf;
enum _Asf {
	_AS_FR = 0,
	_AS_PT = 0,
	_AS_LS = 1,
	_AS_OF = 2,
	_AS_CO = 4,
	_AS_NG = 8
	_AS_FIRST = 0,
	_AS_POINTER = 0,
	_AS_LAST = 1,
	_AS_OFFSET = 2,
	_AS_COUNT = 4,
	_AS_NEGATIVE = 8

};
```

*Name*:

`_Asf` -- Array Search Flags.

*Description*:

The `_Asf` type should large enough to hold the range of values of `_Asf`'s constants.

`_Asf` contains next constants:

- `_AS_FR` signals to search for the first needle (default);

- `_AS_PT` signals to return the pointer to the needle (default);

- `_AS_LS` signals to search for the last needle;

- `_AS_OF` signals to return the offset from the haystack pointer;

- `_AS_CO` signals to return the count of occurrences;

- `_AS_NG` signals to search for the absence of needle;

For more information for these flags, see the functions that accept them.

Aliases:

- `_AS_FIRST` = `_AS_FR`; 

- `_AS_POINTER` = `_AS_PT`;

- `_AS_LAST` = `_AS_LS`;

- `_AS_OFFSET` = `_AS_OF`;

- `_AS_COUNT` = `_AS_CO`;

- `_AS_NEGATIVE` = `_AS_NG`;


==== 5.4.3. _Arf -- Array Replace Flags
`_Arf` is type and an enumerator type. The type is only used in the declarations of `arb` and `ara` as the type of parameter `flags`. The enumerator type holds enumerator constants that can be passed in `flags`, each signalling the way objects will be search and the return value.

*Synopsis*:
```c

typedef unsigned char _Arf;
enum _Arf {
	_AR_FR = 0,
	_AR_LS = 1,
	_AR_AC = 2,
	_AR_AL = 4,
	_AR_FR = 0,
	_AR_NG = 8
	_AR_FIRST = 0,
	_AR_LAST = 1,
	_AR_ANYCHAR = 2,
	_AR_ALL = 4,
	_AR_NEGATIVE = 8

};
```

*Name*:

`_Arf` -- Array Search Flags.

*Description*:

The `_Arf` type should large enough to hold the range of values of `_Arf`'s constants.

`_Arf` contains next constants:

- `_AR_FR` signals to search for the first needle;

- `_AR_LS` signals to search for the last needle;

- `_AR_AL` signals to return the count of occurrences (default);

- `_AR_NG` signals to search for the absence of needle;

_ `_AR_AC` signals to search for the occurrence of any needle byte;

For more information for these flags, see the functions that accept them.

Aliases:

- `_AR_FIRST` = `_AR_FR`; 

- `_AR_LAST` = `_AR_LS`;

- `_AR_ALL` = `_AR_AL`;

- `_AR_NEGATIVE` = `_AR_NG`;

- `_AR_ANYCHAR` = `_AR_AC`;

==== 5.4.4. _afa -- Array Function Assignment
`_afa` is an auxiliary function that performs a selected operation on one or two objects and assigns the result to a specified pointer.

*Synopsis*:
```c
EXTERN char* _afa(char* r, const char* a, const char* b, As size, const _Af func);
```

*Name*: `_afa` -- Array Function Assign.

*Parameters*:
[%autowidth]
|===
| `char*`		| `r`		| Pointer for the result object
| `const char*`	| `a`		| Pointer to the first operand
| `const char*`	| `b`		| Pointer to the second operand
| `As`			| `size`	| The length of operands
| `const _Af`	| `func`	| Bitwise function
|===

*Returns*: pointer to the object where the result of the operation is stored.

*Description*:

Performs a bitwise operation specified by `func` to objects `a` and `b`, with the result being stored in `r`.


==== 5.4.5. _afb -- Array Function Boolean
`_afb` is an auxiliary function that performs a selected operation on one or two objects and returns whether that operation is true or false.

*Synopsis*:
```c
EXTERN Bl _afb(const char* restrict const a, const char* restrict const b, const As size, const _Af func);
```

*Name*: `_afb` -- Array Function Boolean.

*Parameters*:
[%autowidth]
|===
| `const char* restrict const`	| `a`		| Pointer to the first operand
| `const char* restrict const`	| `b`		| Pointer to the second operand
| `const As`					| `size`	| The length of operands
| `const _Af`					| `func`	| Boolean function
|===

*Returns*: _true_ or _false_

*Description*:

For `func == _AF_NO` returns value of `a` cast to `Bl` (by other words, returns true if the object holds a non-zero value).

For `func == _AF_NT` return value of `a` logically negated (by other words, return true if the object holds the value of zero).

For other values of `func`, both objects are cast to `Bl` and the respective logical operation is performed on them.

Special cases:

If `a == NULL`, the function fails, returns a value with all bits set to 1, also throws `ERNULL` error.

If `b == NULL` and `func` does not equal `_AF_NO`|`_AF_NT`, the function fails, returns a value with all bits set to 1, also throws `ERNULL` error.

If a value that is not a enum constant of `_Af` passed to `func`, the function fails, returns a value with all bits set to 1, also throws `ERNULL` error.


== 6. String utilities
== 7. Error handling
=== 7.1. Runtime errors
==== 7.1.1. `ERZERO` (W01) -- Zero parameter
This error is supposed to be raised when a function, with error handling support, has the value of zero passed to one of its scalar parameters, which only accept non-zero values. Error ID: `01`

==== 7.1.2. `ERNULL` (W02) -- Null parameter
This error is supposed to be raised when a function, with error handling support, has the value of null passed to one of its pointer-type parameters, which only accept non-null values. Error ID: `02`

==== 7.1.3. `EROUT` (W03) -- Out of range
This error is supposed to be raised when a function, with error handling support, has the value, that does not belong to the accepted range of values, passed to one of its parameters. Error ID: `03`

=== 7.2. Runtime warnings
==== 7.2.1. `WRZERO` (W01) -- Zero parameter
This warning is supposed to be raised by a function, with error handling support, to inform the user that value of zero that has been passed to a scalar parameter has a special purpose and may cause an unexpected outcome. Warning ID: `01`

==== 7.2.2. `WRNULL` (W02) -- Null parameter
This warning is supposed to be raised by a function, with error handling support, to inform the user that value of null that has been passed to a pointer parameter has a special purpose and may cause an unexpected outcome. Warning ID: `02`

== 8. Configuration
