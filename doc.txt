= WLib Documentation

== 1. System information
=== 1.1. Architectures
=== 1.2. Operating Systems
=== 1.3. Data models
=== 1.4. Compilers
=== 1.5. Language
== 2. C/C++ compatibility
=== 2.1. `enum`
=== 2.2. `extern`
=== 2.3. `inline`
=== 2.4. `restrict`
== 3. Basic types
=== 3.1. Fixed-width numeric types
=== 3.2. C/C++ compatibility types
=== 3.3. Special types
=== 3.4. Type widths
=== 3.5. Type limits
== 4. Character utilities
Below is the table of ASCII character set. 

- Characters belonging to the Control Character Set are inside blue cells (x00--x1F and x7F);
- Characters belonging to the Symbol Character Set are inside yellow cells (x20--x2F and x3A--x40 and x5B--x60 and x7B--x7E);
- Characters belonging to the Digit Character Set are inside pink/magenta cells (x30--x39);
- Characters belonging to the Uppercase Character Set are inside red cells (x41--x5A);
- Characters belonging to the Lowercase Character Set are inside green cells (x61--x7A);
- Characters belonging to the Whitespace Character Set are in red color (x09--x0D);
- The Letter Character Set or Alphabetical Set is a combined set of the Uppercase Character Set and the Lowercase Character Set;
- The Alphanumeric Character Set is a combined set of the Letter Character Set and the Digit Character Set;
- The RFC 4648 Base32 Character Set is a set of characters consisting of the entire Uppercase Letter Character Set, digits from `2` to `7` and the padding character `=`;
- The RFC 4648 Base64 Character Set is a set of characters consisting of the entire Uppercase, Lowercase Letters and Decimal Digit Character Sets, plus character `+`, `/` and the padding character `=`;
- The Extended ASCII Character Set is any character beyond the order number 127 (x7F) or ‚ê° character.
- The Binary Digit Character Set is a set of two characters: `0` and `1`
- The Octal Digit Character Set -- eight characters from `0` to `7`
- The Hexadecimal Digit Character Set -- sixteen characters, including the entire Decimal Digit Character Set and uppercase letter from `A` to `F`
- The Triacontabinary Digit Character Set -- thirty-two character, includes the entire Decimal Digit Character Set and uppercase letter from `A` to `V`
- The Hexecontaquaternary Digit Character Set -- sixty-four character, same as RFC 4648 Base64.

[cols="^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^"]
|===
|			| 00								| 01							| 02							| 03			| 04			| 05		| 06		| 07
| 08		| 09								| 0A							| 0B							| 0C			| 0D			| 0E		| 0F		|
| 00		|{set:cellbgcolor:#EEEEFF} &#9216;	| &#9217;						| &#9218;						| &#9219;		| &#9220;		| &#9221;	| &#9222;	| &#9223;
| &#9224;	|[red]#&#9225;#						|[red]#&#9226;#					|[red]#&#9227;#					|[red]#&#9228;#	|[red]#&#9229;#	| &#9230;	| &#9231;	|{set:cellbgcolor:} 0F
| 10		|{set:cellbgcolor:#EEEEFF} &#9223;	| &#9233;						| &#9234;						| &#9235;		| &#9236;		| &#9237;	| &#9238;	| &#9239;	
| &#9240;	| &#9241;							| &#9242;						| &#9243;						| &#9244;		| &#9245;		| &#9246;	| &#9247;	|{set:cellbgcolor:} 1F
| 20		|{set:cellbgcolor:#FFFFEE} &#9251;	| !								| &quot;						| &num;			| $				| %			| &amp;		| &#39;		
| (			| )									| &ast;							| +								| ,				| -				| .			| /			|{set:cellbgcolor:} 2F
| 30		|{set:cellbgcolor:#FFEEFF} 0		| 1								| 2								| 3				| 4				| 5			| 6			| 7
| 8			| 9									|{set:cellbgcolor:#FFFFEE} :	| ;								| &lt;			| =				| &gt;		| ?			|{set:cellbgcolor:} 3F
| 40		|{set:cellbgcolor:#FFFFEE} @		|{set:cellbgcolor:#FFEEEE} A	| B								| C				| D				| E			| F			| G			
| H			| I									| J								| K								| L				| M				| N			| O			|{set:cellbgcolor:} 4F
| 50		|{set:cellbgcolor:#FFEEEE} P		| Q								| R								| S				| T				| U			| V			| W
| X			| Y									| Z								|{set:cellbgcolor:#FFFFEE} &	| \				| ]				| ^			| _			|{set:cellbgcolor:} 5F
| 60		|{set:cellbgcolor:#FFFFEE} &grave;	|{set:cellbgcolor:#EEFFEE} a	| b								| c				| d				| e			| f			| g
| h			| i									| j								| k								| l				| m				| n			| o			|{set:cellbgcolor:} 6F
| 70		|{set:cellbgcolor:#EEFFEE} p		| q								| r								| s				| t				| u			| v			| w
| x			| y									| z								|{set:cellbgcolor:#FFFFEE} {	| &vert;		| }				| ~			| \			|{set:cellbgcolor:} 7F
|			| 70								| 71							| 72							| 73			| 74			| 75		| 76		| 77
| 78		| 79								| 7A							| 7B							| 7C			| 7D			| 7E		| 7F		|
|===

=== 4.1. Control Characters
The numerical value of ASCII Control Characters can be conveniently accessed using next macros.
[%autowidth]
|===
|DEC|BIN    |OCT|HEX|Name
|0  |0000000|000|00 |`NUL`
|1  |0000001|001|01 |`SOH`
|2  |0000010|002|02 |`STX`
|3  |0000011|003|03 |`ETX`
|4  |0000100|004|04 |`EOT`
|5  |0000101|005|05 |`ENQ`
|6  |0000110|006|06 |`ACK`
|7  |0000111|007|07 |`BEL`
|8  |0001000|010|08 |`BS`
|9  |0001001|011|09 |`HT`
|10 |0001010|012|0A |`LF`
|11 |0001011|013|0B |`VT`
|12 |0001100|014|0C |`FF`
|13 |0001101|015|0D |`CR`
|14 |0001110|016|0E |`SO`
|15 |0001111|017|0F |`SI`
|16 |0010000|020|10 |`DLE`
|17 |0010001|021|11 |`DC1`
|18 |0010010|022|12 |`DC2`
|19 |0010011|023|13 |`DC3`
|20 |0010100|024|14 |`DC4`
|21 |0010101|025|15 |`NAK`
|22 |0010110|026|16 |`SYN`
|23 |0010111|027|17 |`ETB`
|24 |0011000|030|18 |`CAN`
|25 |0011001|031|19 |`EM`
|26 |0011010|032|1A |`SUB`
|27 |0011011|033|1B |`ESC`
|28 |0011100|034|1C |`FS`
|29 |0011101|035|1D |`GS`
|30 |0011110|036|1E |`RS`
|31 |0011111|037|1F |`US`
|127|1111111|177|7F |`DEL`
|===
=== 4.2. Character set checking
Character set checking macro functions check if the specified character belongs to the set of character the function is specified to check against.

*Name*: `ci32`, `ci64`, `cib`, `cic`, `cid`, `cih`, `cihq`, `cil`, `cild`, `cill`, `cin`, `cinx`, `cio`, `cip`, `cis`, `citb`, `ciul`, `civ`, `ciw`, `cix`

*Synopsis*:
```c
#define ci32(c)	...
#define ci64(c)	...
#define cib(c)	...
#define cic(c)	...
#define cid(c)	...
#define cih(c)	...
#define cihq(c)	...
#define cil(c)	...
#define cild(c)	...
#define cill(c)	...
#define cin(c)	...
#define cinx(c)	...
#define cio(c)	...
#define cip(c)	...
#define cis(c)	...
#define citb(c)	...
#define ciul(c)	...
#define civ(c)	...
#define ciw(c)	...
#define cix(c)	...
```

*Description*:

- `ci32` (Character Is Base32) checks for inclusion in RFC 4648 Base32 Character set,
- `ci64` (Character Is Base64) -- RFC 4648 Base64 Character set,
- `cib` (Character Is Binary digit) -- Binary Digit Character set,
- `cic` (Character Is Control) -- Control Character set
- `cid` (Character Is Decimal digit) -- Decimal Digit Character set,
- `cih` (Character Is Hexadecimal digit) -- Hexadecimal Digit Character set,
- `cihq` (Character Is Hexecontaquaternary digit) -- Hexecontaquaternary Digit Character set,
- `cil` (Character Is Letter) -- Alphabetical Character set,
- `cild` (Character Is Letter or Decimal digit) -- Alphanumerical Character set,
- `cill` (Character Is Lowercase Letter) -- Lowercase Letter Character set,
- `cin` (Character Is blaNk) -- Blank Character set,
- `cinx` (Character Is Not eXtended ASCII) -- Base ASCII Character set,
- `cio` (Character Is Octal digit) -- Octal Digit Character set,
- `cip` (Character Is Printable) -- Printable Character set,
- `cis` (Character Is Symbol) -- Symbol Digit Character set,
- `citb` (Character Is Triacontabinary digit) -- Triacontabinary Digit Character set,
- `ciul` (Character Is Uppercase Letter) -- Uppercase Letter Character set,
- `civ` (Character Is Visible) -- Visible Character set,
- `ciw` (Character Is Whitespace) -- Whitespace Digit set,
- `cix` (Character Is eXtended ASCII) -- Extended ASCII Character set

*Returns*: _true_ or _false_ as `const int`.

== 5. Array utilities
=== 5.1. Bitwise arithmetic
Array bitwise arithmetic operation functions are macro function that perform the corresponding logic operation bitwise. 

*Name*: `aan`, `aand`, `anand`, `ann`, `ano`, `anor`, `anot`, `anr`, `ant`, `anx`, `anxor`, `aor`, `axor`, `axr`

*Synopsis*:
```c
#define aan(r,a,b,size)	afa((r),(a),(b),AF_AN,(size))
#define aand	aan
#define anand	ann
#define ann(r,a,b,size)	afa((r),(a),(b),AF_NN,(size))
#define ano(r,a,size)	afa((r),(a),NULL,AF_NO,(size))
#define anor	anr
#define anot	ant
#define anr(r,a,b,size)	afa((r),(a),(b),AF_NR,(size))
#define ant(r,a,size)	afa((r),(a),NULL,AF_NT,(size))
#define anx(r,a,b,size)	afa((r),(a),(b),AF_NX,(size))
#define anxor	anx
#define aor(r,a,b,size)	afa((r),(a),NULL,AF_OR,(size))
#define axor	axr
#define axr(r,a,b,size)	afa((r),(a),NULL,AF_XR,(size))
```

*Description*:

- `aan` (Array AND) performs bitwise AND on two objects pointed by `a` and `b` and the result object is written at `r`;
- `aand` (Array AND) is an alias of `aan`;
- `anand` (Array NAND) is an alias of `ann`;
- `ann` (Array NAND) performs bitwise NAND on two objects pointed by `a` and `b` and the result object is written at `r`;
- `ano` (Array NAND) does not perform any operation on the object pointed by `a` and copies that object to the location `r`
- `anor` is an alias of `anr`;
- `anot` is an alias of `ant`;
- `anr` performs bitwise NOR on two objects pointed by `a` and `b` and the result object is written at `r`;
- `ant` performs bitwise NOT on the object pointed by `a` and the result object is written at `r`;
- `anx` performs bitwise NXOR on two objects pointed by `a` and `b` and the result object is written at `r`;
- `anxor` is an alias of `anx`
- `aor` performs bitwise OR on two objects pointed by `a` and `b` and the result object is written at `r`;
- `axor` is an alias of `axr`;
- `axr` performs bitwise XOR on two objects pointed by `a` and `b` and the result object is written at `r`.

All of these macro functions eventually end up expanding to `afa`, which is actually responsible for performing the respective operations.

*Parameters*:

For `ano`, `ant` and `anot`:

- `a` -- pointer to the operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer.

For `aan`, `ann`, `anr`, `anx`, `aor`, `axr` and their aliases:

- `a` -- pointer to the left operand object;
- `b` -- pointer to the right operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer, the algorithm calls for allocated of size bytes for writing the array; the pointer to that newly allocated sequence of bytes will be assigned to `r`

*Returns*: the value of `r` -- the pointer to the result object

*Configurability*:

If `WL_CONF_XXX_FUNC`, where XXX is the name of macro functions that will expand to 

=== 5.2. Boolean logic
[%autowidth]
|===
|`anol`|Array No Operation Logical
|`antl`|Array NOT Logical
|`aanl`|Array AND Logical
|`aorl`|Array OR Logical
|`axrl`|Array XOR Logical
|`annl`|Array NAND Logical
|`anrl`|Array NOR Logical
|`anxl`|Array NXOR Logical
|===
=== 5.3. Searching & Replacing
==== 5.3.1. `asb` -- Array Search Byte
==== 5.3.2. `asa` -- Array Search Array
==== 5.3.3. `arb` -- Array Search & Replace Byte
==== 5.3.4. `ara` -- Array Search & Replace Array
=== 5.4. Auxiliary Identifiers
== 6. String utilities
== 7. Configuration
