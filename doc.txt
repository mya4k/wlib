= WLib Documentation
:toc:
:CONTROL: #FF0000

[#1_]
[#Intro]
== 1. Introduction
Welcome to the WLib Documentation! This documents is the knowledge base for our library. Here you can learn anything from the concepts to ...

[#1_1_]
[#Concepts]
=== 1.1. Concepts
The *Library* here is defined as the collection of modules.

A *Module* is a subdivision of the library consisting of, as a rule, a single archive/library file and the corresponding header file. (for example, array module consists of the "array.h" header file and the "libwca.a" file in Unix-like systems)

[#2_]
[#Types]
== 2. Basic Types
Types module consists merely of single header: `<types.h>`

Macro objects

.Type limit macros
[%autowidth]
|===
| `CHN``
Mi**n**imal value of `char` type
| `CHX``
Ma**x**imal value of `char` type
| `FALSE`	| Minimal value of `_Bool`/`bool` type (FALSE)
| `I8N``
Mi**n**imal value of `I8` type
| `I8X``
Ma**x**imal value of `I8` type
| `I16N`	| Mi**n**imal value of `I16` type
| `I16X`	| Ma**x**imal value of `I16` type
| `I32N`	| Mi**n**imal value of `I32` type
| `I32X`	| Ma**x**imal value of `I32` type
| `I64N`	| Mi**n**imal value of `I64` type
| `I64X`	| Ma**x**imal value of `I64` type
| `IMN``
Mi**n**imal value of `IMax` type
| `IMX``
Ma**x**imal value of `IMax` type
| `INN``
Mi**n**imal value of `int` type
| `INX``
Ma**x**imal value of `int` type
| `LLN``
Mi**n**imal value of `long long` type
| `LLX``
Ma**x**imal value of `long long` type
| `LON``
Mi**n**imal value of `long` type
| `LOX``
Ma**x**imal value of `long` type
| `SCN``
Mi**n**imal value of `signed char` type
| `SCX``
Ma**x**imal value of `signed char` type
| `SHN``
Mi**n**imal value of `short` type
| `SHX``
Ma**x**imal value of `short` type
| `TRUE`	| Maximal value of `_Bool`/`bool` type (TRUE)
| `U8N``
Mi**n**imal value of `U8` type
| `U8X``
Ma**x**imal value of `U8` type
| `U16N`	| Mi**n**imal value of `U16` type
| `U16X`	| Ma**x**imal value of `U16` type
| `U32N`	| Mi**n**imal value of `U32` type
| `U32X`	| Ma**x**imal value of `U32` type
| `U64N`	| Mi**n**imal value of `U64` type
| `U64X`	| Ma**x**imal value of `U64` type
| `UCN``
Mi**n**imal value of `unsigned char` type
| `UCX``
Ma**x**imal value of `unsigned char` type
| `UIN``
Mi**n**imal value of `unsigned int` type
| `UIX``
Ma**x**imal value of `unsigned int` type
| `ULLN`	| Mi**n**imal value of `unsigned long long` type
| `ULLX`	| Ma**x**imal value of `unsigned long long` type
| `ULN``
Mi**n**imal value of `unsigned long` type
| `ULX``
Ma**x**imal value of `unsigned long` type
| `UMN``
Mi**n**imal value of `UMax` type
| `UMX``
Ma**x**imal value of `UMax` type
| `USN``
Mi**n**imal value of `unsigned short` type
| `USX``
Ma**x**imal value of `unsigned short` type
|===

.Type width macros
[%autowidth]
|===
| `BLB``	|`_Bool`/`bool` type width in **b**its
| `CHB`		|`char` type width in **b**its
| `I8B`		|`I8` type width in **b**its
| `I16B`	| `I16` type width in **b**its
| `I32B`	| `I32` type width in **b**its
| `I64B`	| `I64` type width in **b**its
| `INB`		|`int` type width in **b**its
| `LLB`		|`long long` type width in **b**its
| `LOB`		|`long` type width in **b**its
| `SCB`		|`signed char` type width in **b**its
| `SHB`		|`short` type width in **b**its
| `U8B`		|`U8` type width in **b**its
| `U16B`	| `U16` type width in **b**its
| `U32B`	| `U32` type width in **b**its
| `U64B`	| `U64` type width in **b**its
| `UCB`		|`unsigned char` type width in **b**its
| `UIB`		|`unsigned int` type width in **b**its
| `ULB`		|`unsigned long` type width in **b**its
| `ULLB`	| `unsigned long long` type width in **b**its
| `USB` 	| `unsigned short` type width in **b**its
|===


Typedefs

.Alias types
[%autowidth]
|===
| `Ch`, `ch` | `char`
| `Db`, `db` | `double`
| `Fl`, `fl` | `float`
| `Ld`, `ld` | `long double`
|===

.C/C++ backwards compatibility types
[%autowidth]
|===
| `Vo`, `vo` | `void`
| `Bl`, `bl` | `_Bool`/`bool`
|===

.Fixed-size integer types
[%autowidth]
|===
| `I8`, `i8` | Signed *8*-bit **i**nteger type
| `I16`, `i16` | Signed *16*-bit **i**nteger type
| `I32`, `i32` | Signed *32*-bit **i**nteger type
| `I64`, `i64` | Signed *64*-bit **i**nteger type
| `U8`, `u8` | **U**nsigned *8*-bit integer type
| `U16`, `u16` | **U**nsigned *16*-bit integer type
| `U32`, `u32` | **U**nsigned *32*-bit integer type
| `U64`, `u64` | **U**nsigned *64*-bit integer type
|===

.Special types
[%autowidth]
|===
| `IMax`, `imax` | **Max**imal-width signed **i**nteger type (`intmax_t`)
| `Pt`, `pt` | **P**oin**t**er type (`intptr_t`/`uintptr_t`)
| `UMax`, `umax` | **Max**imal-width **u**nsigned integer type (`uintmax_t`)
|===

[#2_1_]
[#Fixed]
=== 2.1. Fixed-size integer types

```c
typedef /* type */ wl_i8,	wl_I8;
typedef /* type */ wl_i16,	wl_I16;
typedef /* type */ wl_i32,	wl_I32;
typedef /* type */ wl_i64,	wl_I64;
typedef /* type */ wl_u8,	wl_U8;
typedef /* type */ wl_u16,	wl_U16;
typedef /* type */ wl_u32,	wl_U32;
typedef /* type */ wl_u64,	wl_U64;
```

A fixed-size integer type means an integer type, which width stays constant across different system. There are 8 distinct fixed-size integer types. 

Since basic C types (`char`, `short`, `int`, `long`, etc.) widths are not specified in the ISO C standard, it was left for compilers to decide their sizes on their own. The sizes of basic C types are different depending on your Operating System, CPU Architecture, Compiler options, etc. However, rather handily, there a several common data models that majority of systems design their C types according to; the `<sys/damo.h>` is responsible for correctly using system information to define a data model (the `DATA_MODEL` macro). The implementation of fixed-size integer types shall be done through those data models (unless there is a better replacement for this model, in which case let us know).

If `WL_USE_STDINT` macro is defined as TRUE in configuration, fixed-size integer types types will be defined through types defined `<stdint.h>`, otherwise WLib will use the method described above.

A table for integer type reference. Size describes how many bits the library tries to define for the type. The next columns lists unsigned types, separated by a comma, that correspond to the optimal size. The third column does the same as the previous but for singed integer. Other columns show the actual size for the data model.

[cols="^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^"]
|===
.3+|Size .3+|Unsigned .3+|Signed 5+|Data model
2+|LP32, ILP32 .2+|LP64, LLP64 .2+|ILP64 .2+|SILP64
|&lt;C99 / &lt;C++11 | &ge;C99 / &ge;C++11
|8 |`U8`,`u8` |`I8`,`i8` |8 |8 |8 |8 |8
|16 |`U16`,`u16` |`I16`,`i16` |16 |16 |16 |16 |64
|32 |`U32`,`u32` |`I32`,`i32` |32 |32 |32 |64 |64
|64 |`U64`,`u64` |`I64`,`i64` |32 |32/64&ast;	|64 |64 |64
|===
&ast; -- While the `long long int` type has been introduced in ISO C 1999, which is at least 64-bits long, it is unknown whether LP32 and ILP32 data models' `long long int` type is at least 64 or 32 bits and may vary from system to system. Regardless, WLib tries to defined it as `long long int` anyway, when compiler with ISO C99 standard or newer.

[#2_2_]
[#SpecialTypes]
=== 2.2. Special types
```c
typedef /* type */ wl_IMax,	wl_imax;
typedef /* type */ wl_UMax,	wl_umax;
typedef /* type */ wl_Pt,   wl_pt;
```
There are 3 additional useful types defined in `<types.h>`: `Pt`, `IMax` and `UMax`

If `WL_USE_STDINT` macro is defined as TRUE in configuration, these types will be defined through types defined `<stdint.h>` rather than using data models.

==== Pointer type
`Pt` or `pt` &mdash; the pointer type. An integer type large enough to hold the reference to an object. This is intended to be used for casting the pointer value into an arithmetic type for pointer arithmetic. 

For example, take the next piece of code. In order to use arithmetic operations using pointers, we would need to convert then into an arithmetical type. After calculations, we would probably want the result value to be converted back into a pointer value.

```c
void* foo(void* p) {
	return (void*)((Pt)p+1);
}
```

==== Maximal-width types
`IMax` or `imax` is a type for the largest available signed basic integer C type (usually 64-bits)

`UMax` or `umax` is a type for the largest avalible unsigned basic integer C type (usually 64-bits)

[#2_3_]
[#CompatTypes]
=== 2.3. Compatibility types

```c
typedef /* type */	Vo, vo;
typedef /* type */	Bl, bl;
```

`void` type has been added by the ANSI C standard (which means it may not have been supported by pre-standard compilers), WLib defines `Vo` and `vo` types. However, in the implementation of any WLib identifier or a function (except the definition of `Vo` and `vo` types themselves) use of `void` type as-is is allowed, even interchangeably; therefore, `Vo` and `vo` types are mostly viewed as aliases.

While `_Bool` type has only been introduced ten years later with an ISO C 1999 revision. `Bl` or `bl` type ensures to use of the type will not generate any error or warnings and will act as a boolean type for the most part for compilers set to comply with a standard revision prior to `_Bool` 's debut. More specifically `Bl` is defined as the smallest available data type (any 8-bit type), where any non-zero value is considered true and false otherwise. In C++ the default boolean type is `bool`, not `_Bool`, therefore, `Bl` and `bl` are also defined accordingly to the language used.

[#2_4_]
[#AliasType]
=== 2.4. Alias types

```c
typedef char		Ch, ch;
typedef double		Db, db;
typedef float		Fl, fl;
typedef long double	Ld, ld;
```

`Ch` and `ch` are aliases for `char` type.

`Fl` and `fl` are aliases for `float` type.

`Db` and `db` are aliases for `double` type.

`Ld` and `ld` are aliases for `long double` type.

[#2_5_]
[#Width]
=== 2.5. Type width macros

```c
#define BLB		/* const int */
#define CHB		/* const int */
#define I16B	/* const int */
#define I32B	/* const int */
#define I64B	/* const int */
#define I8B		/* const int */
#define INB		/* const int */
#define LLB		/* const int */
#define LOB		/* const int */
#define SCB		/* const int */
#define SHB		/* const int */
#define U16B	/* const int */
#define U32B	/* const int */
#define U64B	/* const int */
#define U8B		/* const int */
#define UCB		/* const int */
#define UIB		/* const int */
#define ULB		/* const int */
#define ULLB	/* const int */
#define USB		/* const int */
```

Sometimes it is useful to have macros that represent the width of a data type. In the code below a function is defined that takes an agrument of type <<CompatTypes,`Bl`>>, basically a single bit, and shifts this bit to the leftmost binary digit of type U64B. To make this shift you need to know the width of the type.

```c
long foo(Bl a) {
	return a<<(ILB-1);
}
```
[%autowidth]
|===
| Type               | Width (bits)
|`Bl`                |`BLB`
|`char`              |`CHB`
|`I8` and `i8`       |`I8B`
|`I16` and `i16`     |`I16B`
|`I32` and `i32`     |`I32B`
|`I64` and `i64`     |`I64B`
|`IMax` and `imax`   |`IMB`        
|`int`               |`INB`        
|`long long`         |`LLB`        
|`long`              |`LOB`        
|`Pt` and `pt`       |`PTB`        
|`short`             |`SHB`        
|`signed char`       |`SCB`        
|`U8` and `u8`       |`U8B`        
|`U16` and `u16`     |`U16B`       
|`U32` and `u32`     |`U32B`       
|`U64` and `u64`     |`U64B`       
|`UMax` and `umax`   |`UMB`        
|`unsigned char`     |`UCB`        
|`unsigned int`      |`UIB`        
|`unsigned long long`|`ULLB`       
|`unsigned long`     |`ULB`        
|`unsigned short`    |`USB`        
|===

[#Limits]
=== 2.6. Type limits macros

```c
#define CHN		/* const int */
#define CHX		/* const int */
#define FALSE	/* const int */
#define I16N	/* const int */
#define I16X	/* const int */
#define I32N	/* const int */
#define I32X	/* const int */
#define I64N	/* const int */
#define I64X	/* const int */
#define I8N		/* const int */
#define I8X		/* const int */
#define IMN		/* const int */
#define IMX		/* const int */
#define IMX		/* const int */
#define INN		/* const int */
#define INX		/* const int */
#define LLN		/* const int */
#define LLX		/* const int */
#define LON		/* const int */
#define LOX		/* const int */
#define SCN		/* const int */
#define SCX		/* const int */
#define SHN		/* const int */
#define SHX		/* const int */
#define TRUE	/* const int */
#define U16N	/* const int */
#define U16X	/* const int */
#define U32N	/* const int */
#define U32X	/* const int */
#define U64N	/* const int */
#define U64X	/* const int */
#define U8N		/* const int */
#define U8X		/* const int */
#define UCN		/* const int */
#define UCX		/* const int */
#define UIN		/* const int */
#define UIX		/* const int */
#define ULLN	/* const int */
#define ULLX	/* const int */
#define ULN		/* const int */
#define ULX		/* const int */
#define UMX		/* const int */
#define USN		/* const int */
#define USX		/* const int */
```

In the table below 
[%autowidth]
|===
| Type               | Minimal value | Maximal value
|`Bl`                |`FALSE`        |`TRUE`
|`char`              |`CHN`          |`CHX`
|`I8` and `i8`       |`I8N`          |`I8X`
|`I16` and `i16`     |`I16N`         |`I16X`
|`I32` and `i32`     |`I32N`         |`I32X`
|`I64` and `i64`     |`I64N`         |`I64X`
|`IMax` and `imax`   |`IMN`          |`IMX`
|`int`               |`INN`          |`INX`
|`long long`         |`LLN`          |`LLX`
|`long`              |`LON`          |`LOX`
|`Pt` and `pt`       |`PTN`          |`PTX`
|`short`             |`SHN`          |`SHX`
|`signed char`       |`SCN`          |`SCX`
|`U8` and `u8`       |`U8N`          |`U8X`
|`U16` and `u16`     |`U16N`         |`U16X`
|`U32` and `u32`     |`U32N`         |`U32X`
|`U64` and `u64`     |`U64N`         |`U64X`
|`UMax` and `umax`   |`UMN`          |`UMX`
|`unsigned char`     |`UCN`          |`UCX`
|`unsigned int`      |`UIN`          |`UIX`
|`unsigned long long`|`ULLN`         |`ULLX`
|`unsigned long`     |`LON`          |`LOX`
|`unsigned short`    |`USN`          |`USX`
|===

== 3. Character manipulation
Character manipulation module is contained in a single header, <char.h>, and provides macros for using control characters by their short names (`ACK`), for checking the set of a chacater (letter, digit, symbol, etc), converting characters from one set to another (from lowercase to uppercase).

Below is the table of ASCII character set. 

- Characters belonging to the Control Character Set are inside blue cells (x00&mdash;x1F and x7F);
- Characters belonging to the Symbol Character Set are inside yellow cells (x20&mdash;x2F and x3A&mdash;x40 and x5B&mdash;x60 and x7B&mdash;x7E);
- Characters belonging to the Digit Character Set are inside pink/magenta cells (x30&mdash;x39);
- Characters belonging to the Uppercase Character Set are inside red cells (x41&mdash;x5A);
- Characters belonging to the Lowercase Character Set are inside green cells (x61&mdash;x7A);
- Characters belonging to the Whitespace Character Set are in red color (x09&mdash;x0D);
- The Letter Character Set is a combined set of the Uppercase Character Set and the Lowercase Character Set;
- The Alphaneumeric Character Set is a combined set of the Letter Character Set and the Digit Character Set;
- The Extended ASCII Character Set is any character beyond the order number 127 (x7F) or ‚ê° character.

[cols="^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^"]
|===
|			| 00								| 01							| 02							| 03			| 04			| 05		| 06		| 07
| 08		| 09								| 0A							| 0B							| 0C			| 0D			| 0E		| 0F		|
| 00		|{set:cellbgcolor:#EEEEFF} &#9216;	| &#9217;						| &#9218;						| &#9219;		| &#9220;		| &#9221;	| &#9222;	| &#9223;
| &#9224;	|[red]#&#9225;#						|[red]#&#9226;#					|[red]#&#9227;#					|[red]#&#9228;#	|[red]#&#9229;#	| &#9230;	| &#9231;	|{set:cellbgcolor:} 0F
| 10		|{set:cellbgcolor:#EEEEFF} &#9223;	| &#9233;						| &#9234;						| &#9235;		| &#9236;		| &#9237;	| &#9238;	| &#9239;	
| &#9240;	| &#9241;							| &#9242;						| &#9243;						| &#9244;		| &#9245;		| &#9246;	| &#9247;	|{set:cellbgcolor:} 1F
| 20		|{set:cellbgcolor:#FFFFEE} &#9251;	| !								| &quot;						| &num;			| $				| %			| &amp;		| &#39;		
| (			| )									| &ast;							| +								| ,				| -				| .			| /			|{set:cellbgcolor:} 2F
| 30		|{set:cellbgcolor:#FFEEFF} 0		| 1								| 2								| 3				| 4				| 5			| 6			| 7
| 8			| 9									|{set:cellbgcolor:#FFFFEE} :	| ;								| &lt;			| =				| &gt;		| ?			|{set:cellbgcolor:} 3F
| 40		|{set:cellbgcolor:#FFFFEE} @		|{set:cellbgcolor:#FFEEEE} A	| B								| C				| D				| E			| F			| G			
| H			| I									| J								| K								| L				| M				| N			| O			|{set:cellbgcolor:} 4F
| 50		|{set:cellbgcolor:#FFEEEE} P		| Q								| R								| S				| T				| U			| V			| W
| X			| Y									| Z								|{set:cellbgcolor:#FFFFEE} &	| \				| ]				| ^			| _			|{set:cellbgcolor:} 5F
| 60		|{set:cellbgcolor:#FFFFEE} &grave;	|{set:cellbgcolor:#EEFFEE} a	| b								| c				| d				| e			| f			| g
| h			| i									| j								| k								| l				| m				| n			| o			|{set:cellbgcolor:} 6F
| 70		|{set:cellbgcolor:#EEFFEE} p		| q								| r								| s				| t				| u			| v			| w
| x			| y									| z								|{set:cellbgcolor:#FFFFEE} {	| &vert;		| }				| ~			| \			|{set:cellbgcolor:} 7F
|			| 70								| 71							| 72							| 73			| 74			| 75		| 76		| 77
| 78		| 79								| 7A							| 7B							| 7C			| 7D			| 7E		| 7F		|
|===

=== 3.1. Control Character Macros
```c
#define WL_NUL	'\000'
#define WL_SOH	'\001'
#define WL_STX	'\002'
#define WL_ETX	'\003'
#define WL_EOT	'\004'
#define WL_ENQ	'\005'
#define WL_ACK	'\006'
#define WL_BEL	'\007'
#define WL_BS	'\010'
#define WL_HT	'\011'
#define WL_LF	'\012'
#define WL_VT	'\013'
#define WL_FF	'\014'
#define WL_CR	'\015'
#define WL_SO	'\016'
#define WL_SI	'\017'
#define WL_DLE	'\020'
#define WL_DC1	'\021'
#define WL_DC2	'\021'
#define WL_DC3	'\021'
#define WL_DC4	'\021'
#define WL_NAK	'\025'
#define WL_SYN	'\026'
#define WL_ETB	'\027'
#define WL_CAN	'\030'
#define WL_EM	'\031'
#define WL_ESC	'\033'
#define WL_FS	'\034'
#define WL_GS	'\035'
#define WL_RS	'\036'
#define WL_US	'\037'
#define WL_DEL	'\177'
```

|===
| Name  | Mnemonics                 | Value
| `NUL` | Null                      | 0x00
| `SOH` | Start of Heading          | 0x01
| `STX` | Start of Text             | 0x02
| `ETX` | End of Text               | 0x03
| `EOT` | End of Transmission       | 0x04
| `ENQ` | Enquiry                   | 0x05
| `ACK` | Acknowledge               | 0x06
| `BEL` | Bell                      | 0x07
| `BS`  | Backspace                 | 0x08
| `HT`  | Horizontal Tabulation     | 0x09
| `LF`  | New Line                  | 0x0A
| `VT`  | Vertical Tabulation       | 0x0B
| `FF`  | Form Feed                 | 0x0C
| `CR`  | Carriage Return           | 0x0D
| `SO`  | Shift Out                 | 0x0E
| `SI`  | Shift In                  | 0x0F
| `DLE` | Data Link Escape          | 0x10
| `DC1` | Device Control 1          | 0x11
| `DC2` | Device Control 2          | 0x12
| `DC3` | Device Control 3          | 0x13
| `DC4` | Device Control 4          | 0x14
| `NAK` | Negative Acknowledge      | 0x15
| `SYN` | Synchronous Idle          | 0x16
| `ETB` | End of Transmission Block | 0x17
| `CAN` | Cancel                    | 0x18
| `EM`  | End Of Medium             | 0x19
| `SUB` | Substitute                | 0x1A
| `ESC` | Escape                    | 0x1B
| `FS`  | File Separator            | 0x1C
| `GS`  | Group Separator           | 0x1D
| `RS`  | Record Separator          | 0x1E
| `US`  | Unit Separator            | 0x1F
| `DEL` | Delete                    | 0x7F
|===

=== 3.2. Checking character types
==== 3.2.1 `cia` &mdash; Character Is Alphanumeric character

```c
#define cia wl_cia
#define wl_cia(a) /* function body */
```

...

[#4_]
[#Array]
== 4. Array utilities
The array module consists of various functions and macro functions, which are handy for performing bitwise arithmetical and boolean algebraic (logical) operations on arrays, searching for values and replacing the values in an array.

==== Functions (26, 48)

Bitwise Arithmetic (8, 13)
[%autowidth]
|===
| `aan`	(`aand`)	| **A**rray Bitwise **AN**D
| `ano`				| **A**rray **N**o **O**peration
| `ann` (`anand`)	| **A**rray Bitwise **N**A**N**D
| `anr` (`anor`)	| **A**rray Bitwise **N**O**R**
| `ant` (`anot`)	| **A**rray Bitwise **N**O**T**
| `anx` (`anxor`)	| **A**rray Bitwise **NX**OR
| `aor`				| **A**rray Bitwise **OR**
| `axr`				| **A**rray Bitwise **X**O**R**
|===

Boolean Algebra (8, 13)
[%autowidth]
|===
| `aanl` (`aandl`)	| **A**rray **AN**D **L**ogical
| `anol`			| **A**rray **N**o **O**peration **L**ogical
| `annl` (`anandl`)	| **A**rray **N**A**N**D **L**ogical
| `anrl` (`anorl`)	| **A**rray **N**O**R** **L**ogical
| `antl` (`anotl`)	| **A**rray **N**O**T** **L**ogical
| `anxl` (`anxor`)	| **A**rray **NX**OR **L**ogical
| `aorl`			| **A**rray **OR** **L**ogical
| `axrl`			| **A**rray **X**O**R** **L**ogical
|===

Comparison (2,6)
[%autowidth]
|===
| `aeq` (`aequals`) 					| **A**rray **Eq**ual
| `anq` (`aneq`, `anoteq`, `anotequal`)	| **A**rray **N**ot E**q**ual
|===

Common functions (6, 14)
[%autowidth]
|===
| `aas` (`aassign`)				| **A**rray **As**sign (Alias of `ano`)
| `afl` (`afill`) 				| **A**rray **F**i**l**l
| `ara` (`arep`, `areplace`)	| **A**rray **R**eplace **A**rray
| `arb` (`arepb`, `areplaceb`)	| **A**rray **R**eplace **B**yte
| `asa` (`asearch`)				| **A**rray **S**earch **A**rray
| `asb` (`asearchb`)			| **A**rray **S**earch **B**yte
|===

Auxiliary functions (2)
[%autowidth]
|===
| `_afa`	| **A**rray **F**unction **A**ssign
| `_afb`	| **A**rray **F**unction **B**oolean
|===

==== Types (3)

Common types (2)
[%autowidth]
|===
| `As`	| **A**rray **S**ize
| `Asf` | **A**rray **S**earch **F**lags
|===

Auxiliary types (1)
[%autowidth]
|===
| `_Af` | **A**rray **F**unctions Flags
|===

==== Values
Array Search Flags (3, 6)
[%autowidth]
|===
| `ASF_CN` (`ASF_COUNT`)		| Return **c**ou**n**t
| `ASF_OR` (`ASF_IN_ORDER`)		| Search in order
| `ASF_PT` (`ASF_POINTER`)		| Return **p**ointer
| `ASF_RV` (`ASF_IN_REVERSE`)	| Search in **r**e**v**erse
| `ASF_OF` (`ASF_OFFSET`)
|===

Array Function Flags (8)
[%autowidth]
|===
| `_AF_AN`	| **AN**D
| `_AF_NN`	| **N**A**N**D
| `_AF_NO`	| *No* Operation
| `_AF_NR`	| **N**O**R**
| `_AF_NT`	| **N**O**T**
| `_AF_NX`	| **NX**OR
| `_AF_OR`	| *OR*
| `_AF_XR`	| **X**O**R**
|===

=== 4.1. Types
==== 4.1.1. Array Size
```c
#define As	wl_As
typedef wl_U16 wl_As;
```
`As` type is the type used to represent a size of the array in bytes, which is an integer value, and is aliased to an integer type at definition in `<wc/array.h>`. In the library, it's used in functions like `_afa` and `_afb` for passing sizes of arrays as parameters. This type is currently aliased to `U16` type because the width of `U8` isn't suffient for larger array, therefore `U16` seems enough. Giant arrays (more than 65535 bytes, for example) are impractical as it takes a lot of time to proccess them, they use a lot of memory, instead of it is smart to proccess sections of the array instead of the entire array; for this reasons, we think 16-bits is the optimal size for this type.

==== 4.1.2. Array Search Flags
```c
#define WL_ASF_IN_ORDER		WL_ASF_OR
#define WL_ASF_IN_REVERSE	WL_ASF_RV
#define WL_ASF_PTRDIFF		WL_ASF_PD
#define WL_ASF_COUNT		WL_ASF_CN

typedef wl_U8	wl_Asf;

ENUM(wl_Asf) {
	WL_ASF_OR = 0,
	WL_ASF_RV = 1,
	WL_ASF_PD = 2,
	WL_ASF_CN = 4
};
```

`Asf` type is intended to store its constant values, or by other words search flags. These flags are signalled to `asb`, `asa`, `arb` and `ara` to control the searching and replacing algorithms and the output of these functions.

****
This type is an enumarated and a typedef type. However, as all enumarated types are same width as `int`, it is unoptimal for this enum as it only stores 4 enumarated constants; therefore, there's a type definiton that defines `Asf` with the type long enough to hold one of 4 different values (`U8`).
****

WLib defines 4 flags for search, some of them can be combined, some have to be used alone:

* `ASF_OR` (`ASF_IN_ORDER`) makes `asb`, `asa` return the location of the first needle from the base pointer, and `arb`, `asa` replace the first needle. Incompatible with `ASF_CN`
* `ASF_RV` (`ASF_IN_REVERSE`) makes `asb`, `asa` return the location of the last needle from the base pointer, and `arb`, `asa` replace the last needle. Incompatible with `ASF_CN`
* `ASF_PD` (`ASF_PTRDIFF`) makes `asb`, `asa` return the difference between the pointer to the needle and the base pointer (the offset from the base pointer). Incompatible with `ASF_CN`; this flag is ignored if passed to `arb` and `ara`.
* `ASF_CN` (`ASF_COUNT`) makes `asb` and `asa` return the quantity of needles in an array, and `arb` and `ara` to replace every needle.

==== 4.1.3. Array Function Type

`_af` is an auxulary type used for `_afa` function.

****
This type is an enumarated and a typedef type. However, as all enumarated types are same width as `int`, it is unoptimal for this enum as it only stores 8 enumarated constants; therefore, there's a type definiton that defines `Asf` with the type long enough to hold one of 8 different values (`U8`).
****

=== 4.2. Functions
==== 4.2.1. Bitwise Arithmetic
Macro f

Macro functions that perform bitwise arithmetic opertations with one or two arrays and assigns the result array into a specified pointer, returning that pointer address, expand to the `_afa` function with the appropriate function flags set. There are 8 of these macro functions with different bitwise arithmetic operations they will perform.

===== 4.2.1.1. `ano` -- Array Bitwise No Operation
```c
#define ano					wl_ano
#define wl_ano(r,a,size)	wl_afa((r),(a),WL_NULL,(size),_WL_AF_NO)
```

Macro function `ano` is called Array Bitwise No Operation because it performs no operation on the array `a`. If the pointer `r` is a null pointer, `ano` calls for memory allocation of `size` bytes. The content of array `a` is copied to `r`. Returns the `` 
===== 4.2.1.2. `aan`, `aand` -- Array Bitwise AND
===== 4.2.1.3. `aor` -- Array Bitwise OR
===== 4.2.1.4. `axr`, `axor` -- Array Bitwise XOR
===== 4.2.1.5. `ant`, `anot` -- Array Bitwise NOT
===== 4.2.1.6. `ann`, `anand` -- Array Bitwise NAND
===== 4.2.1.7. `anr`, `anor` -- Array Bitwise NOR
===== 4.2.1.8. `anx`, `anxor` -- Array Bitwise NXOR
==== 4.2.2. Boolean Logic
===== 4.2.2.1. `anol` -- Array Logical No Operation
===== 4.2.2.2. `aanl`, `aandl` -- Array Logical AND
===== 4.2.2.3. `aorl` -- Array Logical OR
===== 4.2.2.4. `axrl`, `axorl` -- Array Logical XOR
===== 4.2.2.5. `antl`, `anotl` -- Array Logical NOT
===== 4.2.2.6. `annl`, `anandl` -- Array Logical NAND
===== 4.2.2.7. `anrl`, `anorl` -- Array Logical NOR
===== 4.2.2.8. `anxl`, `anxorl` -- Array Logical NXOR
==== 4.2.3. Array Comparison
===== 4.2.3.1. `aeq`, `aequals` -- Arrays Equals
===== 4.2.3.2. `anq`, `aneq`, anoteq`, `anotequals` -- Arrays Not Equals
==== 4.2.4. Filling Arrays
===== 4.2.4.1. `aas`, `aassign` -- Array Assign
===== 4.2.4.2. `afl`, `afill` -- Array Fill
==== 4.2.5. Searching & Replacing
===== 4.2.5.1. `asb` -- Array Search Byte
===== 4.2.5.2. `asa` -- Array Search Array
===== 4.2.5.3. `arb` -- Array Search & Replace Byte
===== 4.2.5.4. `ara` -- Array Search & Replace Array
==== 4.2.6. Auxulary Functions
===== 4.2.6.1. `_afa` -- Array Function Assignment
===== 4.2.6.2. `_afb` -- Array Function Boolean
