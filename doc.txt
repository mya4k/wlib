= WLib Documentation

== 1. System information
=== 1.1. Architectures
=== 1.2. Operating Systems
=== 1.3. Data models
=== 1.4. Compilers
=== 1.5. Language
== 2. C/C++ compatibility
=== 2.1. `enum`
=== 2.2. `extern`
=== 2.3. `inline`
=== 2.4. `restrict`
== 3. Basic types
=== 3.1. Fixed-width numeric types
=== 3.2. C/C++ compatibility types
=== 3.3. Special types
=== 3.4. Type widths
=== 3.5. Type limits
== 4. Character utilities
Below is the table of ASCII character set.

- Characters belonging to the Control Character Set are inside blue cells (x00--x1F and x7F);
- Characters belonging to the Symbol Character Set are inside yellow cells (x20--x2F and x3A--x40 and x5B--x60 and x7B--x7E);
- Characters belonging to the Digit Character Set are inside pink/magenta cells (x30--x39);
- Characters belonging to the Uppercase Character Set are inside red cells (x41--x5A);
- Characters belonging to the Lowercase Character Set are inside green cells (x61--x7A);
- Characters belonging to the Whitespace Character Set are in red color (x09--x0D);
- The Letter Character Set or Alphabetical Set is a combined set of the Uppercase Character Set and the Lowercase Character Set;
- The Alphanumeric Character Set is a combined set of the Letter Character Set and the Digit Character Set;
- The RFC 4648 Base32 Character Set is a set of characters consisting of the entire Uppercase Letter Character Set, digits from `2` to `7` and the padding character `=`;
- The RFC 4648 Base64 Character Set is a set of characters consisting of the entire Uppercase, Lowercase Letters and Decimal Digit Character Sets, plus character `+`, `/` and the padding character `=`;
- The Extended ASCII Character Set is any character beyond the order number 127 (x7F) or ‚ê° character.
- The Binary Digit Character Set is a set of two characters: `0` and `1`
- The Octal Digit Character Set -- eight characters from `0` to `7`
- The Hexadecimal Digit Character Set -- sixteen characters, including the entire Decimal Digit Character Set and uppercase letter from `A` to `F`
- The Triacontabinary Digit Character Set -- thirty-two character, includes the entire Decimal Digit Character Set and uppercase letter from `A` to `V`
- The Hexecontaquaternary Digit Character Set -- sixty-four character, same as RFC 4648 Base64.

[cols="^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^, ^.^"]
|===
|			| 00								| 01							| 02							| 03			| 04			| 05		| 06		| 07
| 08		| 09								| 0A							| 0B							| 0C			| 0D			| 0E		| 0F		|
| 00		|{set:cellbgcolor:#EEEEFF} &#9216;	| &#9217;						| &#9218;						| &#9219;		| &#9220;		| &#9221;	| &#9222;	| &#9223;
| &#9224;	|[red]#&#9225;#						|[red]#&#9226;#					|[red]#&#9227;#					|[red]#&#9228;#	|[red]#&#9229;#	| &#9230;	| &#9231;	|{set:cellbgcolor:} 0F
| 10		|{set:cellbgcolor:#EEEEFF} &#9223;	| &#9233;						| &#9234;						| &#9235;		| &#9236;		| &#9237;	| &#9238;	| &#9239;	
| &#9240;	| &#9241;							| &#9242;						| &#9243;						| &#9244;		| &#9245;		| &#9246;	| &#9247;	|{set:cellbgcolor:} 1F
| 20		|{set:cellbgcolor:#FFFFEE} &#9251;	| !								| &quot;						| &num;			| $				| %			| &amp;		| &#39;		
| (			| )									| &ast;							| +								| ,				| -				| .			| /			|{set:cellbgcolor:} 2F
| 30		|{set:cellbgcolor:#FFEEFF} 0		| 1								| 2								| 3				| 4				| 5			| 6			| 7
| 8			| 9									|{set:cellbgcolor:#FFFFEE} :	| ;								| &lt;			| =				| &gt;		| ?			|{set:cellbgcolor:} 3F
| 40		|{set:cellbgcolor:#FFFFEE} @		|{set:cellbgcolor:#FFEEEE} A	| B								| C				| D				| E			| F			| G			
| H			| I									| J								| K								| L				| M				| N			| O			|{set:cellbgcolor:} 4F
| 50		|{set:cellbgcolor:#FFEEEE} P		| Q								| R								| S				| T				| U			| V			| W
| X			| Y									| Z								|{set:cellbgcolor:#FFFFEE} &	| \				| ]				| ^			| _			|{set:cellbgcolor:} 5F
| 60		|{set:cellbgcolor:#FFFFEE} &grave;	|{set:cellbgcolor:#EEFFEE} a	| b								| c				| d				| e			| f			| g
| h			| i									| j								| k								| l				| m				| n			| o			|{set:cellbgcolor:} 6F
| 70		|{set:cellbgcolor:#EEFFEE} p		| q								| r								| s				| t				| u			| v			| w
| x			| y									| z								|{set:cellbgcolor:#FFFFEE} {	| &vert;		| }				| ~			| \			|{set:cellbgcolor:} 7F
|			| 70								| 71							| 72							| 73			| 74			| 75		| 76		| 77
| 78		| 79								| 7A							| 7B							| 7C			| 7D			| 7E		| 7F		|
|===

=== 4.1. Control Characters
The numerical value of ASCII Control Characters can be conveniently accessed using next macros.
[%autowidth]
|===
|DEC|BIN    |OCT|HEX|Name
|0  |0000000|000|00 |`NUL`
|1  |0000001|001|01 |`SOH`
|2  |0000010|002|02 |`STX`
|3  |0000011|003|03 |`ETX`
|4  |0000100|004|04 |`EOT`
|5  |0000101|005|05 |`ENQ`
|6  |0000110|006|06 |`ACK`
|7  |0000111|007|07 |`BEL`
|8  |0001000|010|08 |`BS`
|9  |0001001|011|09 |`HT`
|10 |0001010|012|0A |`LF`
|11 |0001011|013|0B |`VT`
|12 |0001100|014|0C |`FF`
|13 |0001101|015|0D |`CR`
|14 |0001110|016|0E |`SO`
|15 |0001111|017|0F |`SI`
|16 |0010000|020|10 |`DLE`
|17 |0010001|021|11 |`DC1`
|18 |0010010|022|12 |`DC2`
|19 |0010011|023|13 |`DC3`
|20 |0010100|024|14 |`DC4`
|21 |0010101|025|15 |`NAK`
|22 |0010110|026|16 |`SYN`
|23 |0010111|027|17 |`ETB`
|24 |0011000|030|18 |`CAN`
|25 |0011001|031|19 |`EM`
|26 |0011010|032|1A |`SUB`
|27 |0011011|033|1B |`ESC`
|28 |0011100|034|1C |`FS`
|29 |0011101|035|1D |`GS`
|30 |0011110|036|1E |`RS`
|31 |0011111|037|1F |`US`
|127|1111111|177|7F |`DEL`
|===
=== 4.2. Character set checking
Character set checking macro functions check if the specified character belongs to the set of character the function is specified to check against.

*Name*: `ci32`, `ci64`, `cib`, `cic`, `cid`, `cih`, `cihq`, `cil`, `cild`, `cill`, `cin`, `cinx`, `cio`, `cip`, `cis`, `citb`, `ciul`, `civ`, `ciw`, `cix`

*Synopsis*
```c
#define ci32(c)	...
#define ci64(c)	...
#define cib(c)	...
#define cic(c)	...
#define cid(c)	...
#define cih(c)	...
#define cihq(c)	...
#define cil(c)	...
#define cild(c)	...
#define cill(c)	...
#define cin(c)	...
#define cinx(c)	...
#define cio(c)	...
#define cip(c)	...
#define cis(c)	...
#define citb(c)	...
#define ciul(c)	...
#define civ(c)	...
#define ciw(c)	...
#define cix(c)	...
```

*Description*

- `ci32` (Character Is Base32) checks for inclusion in RFC 4648 Base32 Character set,
- `ci64` (Character Is Base64) -- RFC 4648 Base64 Character set,
- `cib` (Character Is Binary digit) -- Binary Digit Character set,
- `cic` (Character Is Control) -- Control Character set
- `cid` (Character Is Decimal digit) -- Decimal Digit Character set,
- `cih` (Character Is Hexadecimal digit) -- Hexadecimal Digit Character set,
- `cihq` (Character Is Hexecontaquaternary digit) -- Hexecontaquaternary Digit Character set,
- `cil` (Character Is Letter) -- Alphabetical Character set,
- `cild` (Character Is Letter or Decimal digit) -- Alphanumerical Character set,
- `cill` (Character Is Lowercase Letter) -- Lowercase Letter Character set,
- `cin` (Character Is blaNk) -- Blank Character set,
- `cinx` (Character Is Not eXtended ASCII) -- Base ASCII Character set,
- `cio` (Character Is Octal digit) -- Octal Digit Character set,
- `cip` (Character Is Printable) -- Printable Character set,
- `cis` (Character Is Symbol) -- Symbol Digit Character set,
- `citb` (Character Is Triacontabinary digit) -- Triacontabinary Digit Character set,
- `ciul` (Character Is Uppercase Letter) -- Uppercase Letter Character set,
- `civ` (Character Is Visible) -- Visible Character set,
- `ciw` (Character Is Whitespace) -- Whitespace Digit set,
- `cix` (Character Is eXtended ASCII) -- Extended ASCII Character set.

*Parameters*: `c` -- character to be checked.

*Returns*: _true_ or _false_.


== 5. Array utilities
=== 5.1. Bitwise arithmetic
Array bitwise arithmetic operation functions are macro function that perform the corresponding logic operation bitwise. 

*Name*: `aan`, `aand`, `anand`, `ann`, `ano`, `anor`, `anot`, `anr`, `ant`, `anx`, `anxor`, `aor`, `axor`, `axr`

*Synopsis*
```c
#define aan(r,a,b,size)	afa((r),(a),(b),AF_AN,(size))
#define aand	aan
#define anand	ann
#define ann(r,a,b,size)	afa((r),(a),(b),AF_NN,(size))
#define ano(r,a,size)	afa((r),(a),NULL,AF_NO,(size))
#define anor	anr
#define anot	ant
#define anr(r,a,b,size)	afa((r),(a),(b),AF_NR,(size))
#define ant(r,a,size)	afa((r),(a),NULL,AF_NT,(size))
#define anx(r,a,b,size)	afa((r),(a),(b),AF_NX,(size))
#define anxor	anx
#define aor(r,a,b,size)	afa((r),(a),NULL,AF_OR,(size))
#define axor	axr
#define axr(r,a,b,size)	afa((r),(a),NULL,AF_XR,(size))
```

*Description*

[%autowidth]
|===
|`aan`	|**A**rray **AN**D		|performs bitwise AND on two objects pointed by `a` and `b` and the result object is written at `r`
|`aand`	|**A**rray *AND*		|is an alias of `aan`
|`anand`|**A**rray *NAND*		|is an alias of `ann`
|`ann`	|**A**rray **N**A**N**D	|performs bitwise NAND on two objects pointed by `a` and `b` and the result object is written at `r`
|`ano`	|**A**rray No Operation	|does not perform any operation on the object pointed by `a` and copies that object to the location `r`
|`anor`	|**A**rray *NOR*		|is an alias of `anr`
|`anot`	|**A**rray *NOT*		|is an alias of `ant`
|`anr`	|**A**rray **N**O**R**	|performs bitwise NOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`ant`	|**A**rray **N**O**T**	|performs bitwise NOT on the object pointed by `a` and the result object is written at `r`
|`anx`	|**A**rray **NX**OR		|performs bitwise NXOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`anxor`|**A**rray *NXOR*		|is an alias of `anx`
|`aor`	|**A**rray *OR*			|performs bitwise OR on two objects pointed by `a` and `b` and the result object is written at `r`
|`axor`	|**A**rray *XOR*		|is an alias of `axr`
|`axr`	|**A**rray **X**O**R**	|performs bitwise XOR on two objects pointed by `a` and `b` and the result object is written at `r` 
|===

All of these macro functions eventually end up expanding to `afa`, which is actually responsible for performing the respective operations.

*Parameters*

For `ano`, `ant` and `anot`:

- `a` -- pointer to the operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer.

For `aan`, `ann`, `anr`, `anx`, `aor`, `axr` and their aliases:

- `a` -- pointer to the left operand object;
- `b` -- pointer to the right operand object;
- `r` -- a pointer where the result object of the operation will be stored. If this parameter is a null pointer, the algorithm calls for allocated of size bytes for writing the array; the pointer to that newly allocated sequence of bytes will be assigned to `r`

*Returns*: the value of `r` -- the pointer to the result object

*Configurability*

Next configuration flags are applicable for these functions: `WL_CONF_AAN_FUNC`, `WL_CONF_ANN_FUNC`, `WL_CONF_ANO_FUNC`, `WL_CONF_ANR_FUNC`, `WL_CONF_ANT_FUNC`, `WL_CONF_ANX_FUNC`,`WL_CONF_AOR_FUNC`, `WL_CONF_AXR_FUNC`.


=== 5.2. Boolean logic
Array bitwise arithmetic operation functions are macro function that perform the corresponding logical or standard boolean algebraic operation.

[%autowidth]
|===
|`aanl`		|**A**rray **AN**D **L**ogical	|performs bitwise AND on two objects pointed by `a` and `b` and the result object is written at `r`
|`aandl`	|**A**rray *AND* **L**ogical	|is an alias of `aan`
|`anandl`	|**A**rray *NAND* **L**ogical	|is an alias of `ann`
|`annl`		|**A**rray **N**A**N**D **L**ogical	|performs bitwise NAND on two objects pointed by `a` and `b` and the result object is written at `r`
|`anol`		|**A**rray **N**o **O**peration **L**ogical	|does not perform any operation on the object pointed by `a` and copies that object to the location `r`
|`anorl`	|**A**rray *NOR* **L**ogical	|is an alias of `anr`
|`anotl`	|**A**rray *NOT* **L**ogical	|is an alias of `ant`
|`anrl`		|**A**rray **N**O**R** **L**ogical	|performs bitwise NOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`antl`		|**A**rray **N**O**T** **L**ogical	|performs bitwise NOT on the object pointed by `a` and the result object is written at `r`
|`anxl`		|**A**rray **NX**OR **L**ogical	|performs bitwise NXOR on two objects pointed by `a` and `b` and the result object is written at `r`
|`anxorl`	|**A**rray *NXOR* **L**ogical	|is an alias of `anx`
|`aorl`		|**A**rray *OR* **L**ogical	|performs bitwise OR on two objects pointed by `a` and `b` and the result object is written at `r`
|`axorl`	|**A**rray *XOR* **L**ogical	|is an alias of `axr`
|`axrl`		|**A**rray **X**O**R** **L**ogical	|performs bitwise XOR on two objects pointed by `a` and `b` and the result object is written at `r`
|===


=== 5.3. Searching & Replacing
==== 5.3.1. `asb` -- Array Search Byte
`asb` is a data search utility that looks for the first, last occurrence or the total amount of occurrences of specified byte value

*Synopsis*:
```c
#define asb(a,s,b,flags)	_asb((char*)(a),(s),(b),(flags))
EXTERN Pt _asb(const char* const restrict a, As s, const char b, const _Asf flags);
```

*Name*: `asb` -- Array Search Byte

*Parameters*

[%autowidth]
|===
|			| `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `size`	| size of the object in bytes
| `char`	| `b`		| byte value to be searched for (needle)
| `_Asf`	| `flag`	| appropriate Search Flags ORed togethers
|===

`a` should be of any integer or pointer type.

*Returns*: `Pt`.

*Description*

Check for any byte with value `b`.

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

Flags for tweaking the search target:

- If `AS_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of byte `b`.

Flags for tweaking the return value:

- If `AS_FR` or `AS_FIRST` flag is set or implied, only looks looks for the first occurrence;

- if `AS_LS` or `AS_LAST` flag is set, only looks looks for the last occurrence;

- if `AS_CO` or `AS_COUNT` flag is set, the number of occurrence is returned;

- if `AS_OF` or `AS_OFFSET` flag is set, pointer difference between the base of object `a` (i.e. the value passed as a parameter) and the location of the needle byte, if found, otherwise returns `PTX`;

- if `AS_PT` or `AS_POINTER` flag is set or implied, returns the pointer to the needle byte, if found, otherwise returns `PTN` (`NULL`).

Default flags are: `AS_FR` and `AS_PT`


==== 5.3.2. `asa` -- Array Search Array
`asa` is a data search utility that looks for the first, last occurrence or the total amount of occurrences of specified object in a larger object.

*Synopsis*:
```c
#define asa(a,sa,b,sb,flags)	_asa((char*)(a),(sa),(char*)(b),(sb),(flags))
EXTERN void* _asa(const char* const restrict a, As s, const char* b, As b, const _Asf flags);
```

*Name*: `asa` -- Array Search Array

*Parameters*

[%autowidth]
|===
|			| `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `size`	| size of the object `a` in bytes
|			| `b`		| pointer to the object to be searched for (needle)
| `As`		| `size`	| size of the object `b` in bytes
| `_Asf`	| `flag`	| appropriate Search Flags ORed togethers
|===

`a` and `b` should be of any integer or pointer type.

*Returns*: `Pt`.

*Description*

Checks for an occurrence of object `b` in object `a`

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

- If `b` is NULL or `sb` is 0, returns immediately as if no occurrences were found, however, with `AS_NEGATIVE` the count of occurrences will be equal to `PTX`, the last occurrence will be the end of object `a` and the first occurrence at its base; also sends WL_ERRNUL

Flags for tweaking the search target:

- If `AS_AC` or `AS_ANYCHAR` flag is set, instead of looking for the occurrence of object `b`, the algorithm will look for the occurrence of any byte in the object `b`.

- If `AS_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of object `b`. With `AS_AC` or `AS_ANYCHAR` flag, the algorithm will look for the occurrence of any byte values that object `b` is not comprised of.

Flags for tweaking the return value:

- If `AS_FR` or `AS_FIRST` flag is set or implied, only looks looks for the first occurrence;

- if `AS_LS` or `AS_LAST` flag is set, only looks looks for the last occurrence;

- if `AS_CO` or `AS_COUNT` flag is set, the number of occurrence is returned;

- if `AS_OF` or `AS_OFFSET` flag is set, pointer difference between the base of object `a` (i.e. the value passed as a parameter) and the location of the needle object, if found, otherwise returns `PTX`;

- if `AS_PT` or `AS_POINTER` flag is set or implied, returns the pointer to the needle object, if found, otherwise returns `PTN` (`NULL`).

Default flags are: `AS_FR` and `AS_PT`


==== 5.3.3. `arb` -- Array Replace Byte

`arb` is a data modification utility that replaces the first, the last or all occurrences of byte `b` with byte `c` in object `a`.

*Synopsis*:
```c
#define arb(a,sa,b,c,flag) ((a) = _arb((char*)(a),(sa),(b),(c),(flag)))
EXTERN char* _arb(char* a, As sa, const char b, const char c, const _Asf flag)
```

*Name*: `arb` -- Array Replace Byte

*Parameters*

[%autowidth]
|===
|           | `a` 		| pointer to the object which will be searched (haystack)
| `As`		| `size`	| size of the object in bytes
| `char`	| `b`		| byte value to be searched for (needle)
| `char`	| `c`		| byte value to replace to (replacement)
| `_Asf`	| `flag`	| appropriate Search Flags ORed togethers
|===

`a` should be of any non-constant integer or pointer type and its object should be of non-const type, because it is a subject to modification and reallocation.

*Returns*: `char*` -- pointer to the modified object `a`

*Description*:

Replaces the first, last or all occurrences of byte `b` with byte `c` in object `a`. 

If the sizes of the object `b` and the object `c` are different, the resulting size of object `a` is subject to change. If object size of `c` is bigger than of `b` and replacements have been made, the size of object `a` has increased, therefore it is a subject to reallocation, the algorithm will also assign the return value to `a` for you; unless the WL_CONF_CALL_MAL flag is set to 0, in which case the overflowing bytes will be written right outside the bounds of object `a`.

Special cases:

- If `a` is NULL or `sa` is 0, returns immediately as if no occurrences were found, also sends WL_ERRNUL.

Flags for tweaking the search targ

- If `AS_NG` or `AS_NEGATIVE` flag is set, the algorithm will look for the absence of occurrence of byte `b`, and if found, will replace those byte with `c`

Flags for tweaking the return value:

- If `AS_FR` or `AS_FIRST` flag is set or implied, only replaces the first occurrence;

- if `AS_LS` or `AS_LAST` flag is set, only replaces the last occurrence;

- If `AR_ALL` flag is set, the every occurrence will be replaced;

==== 5.3.4. `ara` -- Array Replace Array


=== 5.4. Auxiliary Identifiers
== 6. String utilities
== 7. Configuration
